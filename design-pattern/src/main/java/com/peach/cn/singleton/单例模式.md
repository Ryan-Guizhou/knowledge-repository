# 单例模式详解

## 什么是单例模式？

**单例模式（Singleton Pattern）** 是一种 **创建型设计模式**，它确保一个类在整个应用程序的生命周期内 **只有一个实例**，并提供一个全局访问点来获取该实例。

## 单例模式的应用场景

- **全局配置管理** - 例如，读取应用程序的配置文件，确保所有模块访问的都是相同的配置对象。
- **日志管理** - 日志记录器（Logger）通常使用单例模式，以确保所有日志写入到同一个文件或存储系统。
- **数据库连接池** - 连接池通常使用单例模式，以避免重复创建连接，降低系统资源消耗。
- **线程池** - 线程池管理器通常作为单例存在，以便所有线程复用相同的资源。
- **缓存管理** - 例如 Redis 连接实例，多个组件可以共享同一个 Redis 连接实例。
- **计数器** - 例如网站访问量统计，如果每次访问都创建一个新实例，统计数据就会混乱。
- **操作系统设备管理** - 例如打印机管理器，避免多个打印任务同时访问同一个打印机导致冲突。

## 单例模式的实现方式

### 1. 饿汉式（Eager Initialization）

```
public class Singleton {
    private static final Singleton instance = new Singleton(); // 直接创建实例

    private Singleton() {} // 私有构造方法，防止外部实例化

    public static Singleton getInstance() {
        return instance;
    }
}
```

#### ✅ 优点：

- 线程安全，类加载时就完成实例化，避免了多线程同步问题。
- 访问速度快，不需要加锁。

#### ❌ 缺点：

- 提前创建实例，可能会导致资源浪费。
- 不能延迟加载。

### 2. 懒汉式（Lazy Initialization）

```
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // 只有在第一次调用时才创建实例
        }
        return instance;
    }
}
```

#### ✅ 优点：

- 只有在需要时才创建实例，避免资源浪费。

#### ❌ 缺点：

- **线程不安全**，多个线程同时调用 `getInstance()` 可能会创建多个实例。

### 3. 线程安全的懒汉式（synchronized 版本）

```
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

#### ✅ 优点：

- 线程安全，保证只有一个实例。

#### ❌ 缺点：

- `synchronized` 会影响性能，每次获取实例都要加锁，开销较大。

### 4. 双重检查锁（Double-Checked Locking）

```
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### ✅ 优点：

- 线程安全，保证只有一个实例。
- 只在第一次创建实例时加锁，后续访问不会再加锁，提升性能。

#### ❌ 缺点：

- `volatile` 关键字在某些老版本 JDK（如 JDK 1.4 及以下）中可能不支持。

### 5. 静态内部类（推荐方式）

```
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

#### ✅ 优点：

- 线程安全，利用 **JVM 类加载机制** 确保 `INSTANCE` 只被初始化一次。
- **延迟加载**，只有在第一次调用 `getInstance()` 时才会创建实例，避免资源浪费。
- 代码简洁，高效，推荐使用。

#### ❌ 缺点：

- 仅适用于 Java，不适用于某些特殊环境（如某些依赖不同类加载器的应用）。

### 6. 枚举单例（Enum Singleton）

```
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        System.out.println("Doing something...");
    }
}
```

#### ✅ 优点：

- **线程安全**，枚举的实例创建是由 JVM 保证的，避免反序列化和反射攻击。
- **防止反序列化破坏单例**，不需要额外实现 `readResolve()` 方法。

#### ❌ 缺点：

- 不能延迟加载，枚举类型的实例在类加载时就会被创建。
- 不能灵活扩展（例如不支持继承其他类）。

## 不同实现方式对比

| 方式               | 是否线程安全 | 是否支持懒加载 | 性能 | 适用场景                                 |
| ------------------ | ------------ | -------------- | ---- | ---------------------------------------- |
| **饿汉式**         | 是           | 否             | 快   | 适用于类加载即创建实例的场景             |
| **懒汉式**         | 否           | 是             | 慢   | 适用于单线程环境，不推荐用于多线程       |
| **线程安全懒汉式** | 是           | 是             | 慢   | 适用于需要保证线程安全的场景，但性能较差 |
| **双重检查锁**     | 是           | 是             | 较快 | 适用于多线程环境，推荐使用               |
| **静态内部类**     | 是           | 是             | 快   | 推荐使用，兼具线程安全和懒加载           |
| **枚举单例**       | 是           | 否             | 快   | 适用于防止反序列化和反射攻击的场景       |

## 总结

- **如果需要懒加载**，推荐使用 **静态内部类**。
- **如果需要防止反序列化攻击**，推荐使用 **枚举单例**。
- **如果实例初始化开销不大，且不介意类加载时创建实例**，可以使用 **饿汉式**。
- **如果不考虑并发，单线程下使用懒汉式可以更省资源**。
- **如果要兼顾线程安全与性能，推荐双重检查锁（DCL）或静态内部类**。